#' time match logger data
#'
#' @description timematch of simoultaneously received signals by stations 
#'
#'
#' @author Jannis Gottwald
#'
#'
#' 
#' @param animal list, list generated by initAnimal functiom
#' @param method string, which bearing calculation method ("linear", "acos", "ML")
#' @param collision logical, if collision corrected data is used a suffix is added to resulting file name
#' 
#'
#' @export
#'
#'


time_match_station<-function(animal, method, collision=FALSE){
#get timenatches-
fls<-list.files(animal$path$bearings,full.names = T)

data<-plyr::ldply(fls, function(x){data.table::fread(x)})
data$timestamp<-as.character(data$timestamp)
grid<-expand.grid(unique(data$station),unique(data$station))
grid<-grid[grid$Var1!=grid$Var2,]
indx <- !duplicated(t(apply(grid, 1, sort))) # finds non - duplicates in sorted rows
grid<-grid[indx, ] # selects only the non - duplicates according to that index

df<-data.frame()
for(i in 1:nrow(grid)){
  
tmp<-data[data$station==grid$Var1[i] | data$station==grid$Var2[i],]
dcst1<-data.table::dcast(tmp, timestamp~station, value.var =method , mean)
dcst1$name_s1<-names(dcst1)[2]
dcst1$name_s2<-names(dcst1)[3]
colnames(dcst1)<-c("timestamp", "s1", "s2", "name_s1", "name_s2")
dcst2<-data.table::dcast(tmp, timestamp~station, value.var = "antennas", mean)
colnames(dcst2)<-c("timestamp", "antennas_s1", "antennas_s2")
dcst3<-data.table::dcast(tmp, timestamp~station, value.var = "max_dB", mean)
colnames(dcst3)<-c("timestamp", "max_dB_s1", "max_dB_s2")
dcst<-merge(dcst1, dcst2, by="timestamp") 
dcst<-merge(dcst, dcst3, by="timestamp") 

df<-rbind(df, dcst)
}


if(collision==TRUE){
  data.table::fwrite(df, paste0(animal$path$station_timematch, "/", anml$meta$animalID,"_FROM_", as.Date(min(data$timestamp)), "_TO_",as.Date(max(data$timestamp)),"_station_timematch_", method,"_collision.csv"))}
if(collision==FALSE){
data.table::fwrite(df, paste0(animal$path$station_timematch, "/", anml$meta$animalID,"_FROM_", as.Date(min(data$timestamp)), "_TO_",as.Date(max(data$timestamp)),"_station_timematch_", method,".csv"))}

return(data)

}

